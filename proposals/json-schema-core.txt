


Internet Engineering Task Force                            fge. Galiegue
Internet-Draft
Intended status: Informational                               K. Zyp, Ed.
Expires: March 19, 2013                                    SitePen (USA)
                                                                G. Court
                                                      September 15, 2012


               JSON Schema: core definitions and purposes
                            json-schema-core

Abstract

   JSON Schema defines the media type "application/schema+json", a JSON
   based format for defining the structure of JSON data.  JSON Schema
   provides a contract for what JSON data is required for a given
   application and how to interact with it.  JSON Schema is intended to
   define validation, documentation, hyperlink navigation, and
   interaction control of JSON data.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on March 19, 2013.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must



Galiegue, et al.         Expires March 19, 2013                 [Page 1]

Internet-Draft                 JSON Schema                September 2012


   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Conventions and Terminology  . . . . . . . . . . . . . . . . .  3
   3.  Core terminology of JSON Schema  . . . . . . . . . . . . . . .  3
     3.1.  JSON Schema, keywords  . . . . . . . . . . . . . . . . . .  3
     3.2.  Enclosing schema, root schema  . . . . . . . . . . . . . .  3
     3.3.  JSON Schema primitive types  . . . . . . . . . . . . . . .  4
     3.4.  JSON value equality  . . . . . . . . . . . . . . . . . . .  4
     3.5.  Instance . . . . . . . . . . . . . . . . . . . . . . . . .  5
   4.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     4.1.  Design Considerations  . . . . . . . . . . . . . . . . . .  5
   5.  JSON Schema identification . . . . . . . . . . . . . . . . . .  6
     5.1.  Purpose of this section  . . . . . . . . . . . . . . . . .  6
     5.2.  Meta-schema identification using $schema . . . . . . . . .  6
     5.3.  Root schema identification . . . . . . . . . . . . . . . .  6
     5.4.  Subschema identification . . . . . . . . . . . . . . . . .  6
     5.5.  Identification using \\"id\\"  . . . . . . . . . . . . . .  6
   6.  JSON Schema referencing  . . . . . . . . . . . . . . . . . . .  7
     6.1.  Purpose of this section  . . . . . . . . . . . . . . . . .  7
     6.2.  Determining the URI of a schema  . . . . . . . . . . . . .  7
     6.3.  Loading schemas using JSON Reference . . . . . . . . . . .  8
     6.4.  The "json-schema" fragment resolution scheme . . . . . . .  8
   7.  Schema/Instance Association  . . . . . . . . . . . . . . . . .  8
     7.1.  Purpose of this section  . . . . . . . . . . . . . . . . .  8
     7.2.  Recommended correlation mechanisms for use with the
           HTTP protocol  . . . . . . . . . . . . . . . . . . . . . .  8
       7.2.1.  Correlation by means of the "Content-Type" header  . .  9
       7.2.2.  Correlation by means of the "Link" header  . . . . . .  9
   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . .  9
   9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 10
     9.1.  Normative References . . . . . . . . . . . . . . . . . . . 10
     9.2.  Informative References . . . . . . . . . . . . . . . . . . 10
   Appendix A.  ChangeLog . . . . . . . . . . . . . . . . . . . . . . 10













Galiegue, et al.         Expires March 19, 2013                 [Page 2]

Internet-Draft                 JSON Schema                September 2012


1.  Introduction

   JSON Schema is a JSON media type for defining the structure of JSON
   data.  JSON Schema provides a contract for what JSON data is required
   for a given application and how to interact with it.  JSON Schema is
   intended to define validation, documentation, hyperlink navigation,
   and interaction control of JSON data.

   This document defines the core terminology used by JSON Schema.
   Other linked specifications, which expand on a particular role of
   JSON Schema, will use that terminology.

   This document also defines the mechanisms used for JSON Schema
   identification and referencing.

2.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

   The terms "JSON", "JSON text", "JSON value", "member", "element",
   "object", "array", "number", "string", "boolean", "true", "false",
   and "null" in this document are to be interpreted as defined in RFC
   4627 [RFC4627].

3.  Core terminology of JSON Schema

3.1.  JSON Schema, keywords

   A JSON Schema is a JSON document, and that document MUST be an
   object.  Object members of a JSON Schema are called keywords, or
   schema keywords.

   A JSON Schema MAY be empty.

3.2.  Enclosing schema, root schema

   JSON Schemas can be nested, as in this example:


   {
       "title": "root",
       "otherschema": {
           "title": "nested",
           "anotherschema": {
               "title": "alsonested"
           }



Galiegue, et al.         Expires March 19, 2013                 [Page 3]

Internet-Draft                 JSON Schema                September 2012


       }
   }


   In this example, the enclosing schema of both "nested" and
   "alsonested" is "root".  The schema with title "root" is said to be a
   root schema because it is not enclosed within another schema.

3.3.  JSON Schema primitive types

   JSON Schema defines seven primitive types for JSON values:

   array  A JSON array.

   boolean  A JSON boolean (true or false).

   integer  A JSON number without a decimal part.

   number  Any JSON number.  Number includes integer.

   null  The JSON null value.

   object  A JSON object.

   string  A JSON string.

3.4.  JSON value equality

   Two JSON values are said to be equal if and only if:

      both are nulls; or

      both are booleans or strings, and have the same value; or

      both are numbers, and have the same JSON reprensetation; or

      both are arrays, and:

         have the same number of elements; and

         elements at the same index are equal according to this
         definition; or

      both are objects, and:

         have the same set of members; and





Galiegue, et al.         Expires March 19, 2013                 [Page 4]

Internet-Draft                 JSON Schema                September 2012


         values for a same member are equal according to this
         definition.

   Note about numbers: the two JSON number values, 1.0 and 1, for
   instance, are mathematically equivalent; however they are NOT equal,
   since their JSON representation differs.

3.5.  Instance

   An instance is any JSON value being processed by a JSON Schema.  The
   specification may also refer to an instance as a JSON instance.

4.  Overview

   JSON Schema defines the media type "application/schema+json" for
   describing the structure of JSON instances.  JSON Schemas are
   themselves written in JSON and include facilities for describing the
   structure of JSON in terms of allowable values, descriptions, and
   interpreting relations with other resources.

   JSON Schema serves different purposes, which are summarized below.
   Each purpose has a defined set of keywords which is described in its
   own specification.

   Documentation  JSON Schema can be used to decorate either itself, or
      instances, with descriptive text highlighting the schema's, or
      instance's, purposes.

   Hyperlinking  JSON Schema can be used to associate an instance to a
      Link Description Object, as defined by FIXME.

   Validation  JSON Schema can be used to validate the structure of an
      instance.  Keywords also exist for semantic analysis, although
      implementations are not required to implement them.

4.1.  Design Considerations

   JSON Schema provides a separate format for flexibly communicating how
   a JSON value should be interpreted and/or validated, such that
   clients can properly understand acceptable structures for, and/or
   extract the needed information from, the JSON instance being
   processed.

   It is acknowledged that JSON values can be of any type defined by the
   JSON specification.  As such, JSON Schema does not mandate that an
   instance be of a particular type: JSON Schema can process any JSON
   value, including null.  It is the domain of JSON Schema validation to
   add useful constraints to the structure and, optionally, semantics,



Galiegue, et al.         Expires March 19, 2013                 [Page 5]

Internet-Draft                 JSON Schema                September 2012


   of the JSON instance being processed.

   JSON Schema is agnostic with regards to both protocols and
   programming languages.  In particular, this means that defining the
   semantics of the client-server interface is dependent on the protocol
   being used.

5.  JSON Schema identification

5.1.  Purpose of this section

   This section describes the available mechanisms for identifying the
   schema in a unique way: its location, but also the version of the
   JSON Schema specification it is written against.

5.2.  Meta-schema identification using $schema

   TODO -- core schema, hyper schema, etc etc...

5.3.  Root schema identification

   A root schema MAY be uniquely identified by the presence of a
   "location" keyword.  This keyword's value MUST be a string, and this
   string MUST be a URI; the URI MUST be absolute, and MUST have either
   no fragment, or an empty fragment.

   This keyword MUST NOT be used in subschemas.

5.4.  Subschema identification

   Within JSON Schemas, a subschema MAY be identified by the presence of
   a "subId" keyword.  This keyword's value MUST be a string.

   This string MUST NOT be empty.  It MUST NOT start with a solidus (/).
   A same string MUST NOT be used more than once in a same root schema.

   This keyword MAY also be used in a root schema.

5.5.  Identification using \\"id\\"

   The value for this keyword MUST be a string.  This string MUST be a
   URI.

   For backwards compatibility, JSON Schemas MAY use the "id" keyword
   for identification purposes.  However, due to numerous ambiguity
   concerns, this is NOT RECOMMENDED.

   Schema authors willing to use "id" for identification purposes SHOULD



Galiegue, et al.         Expires March 19, 2013                 [Page 6]

Internet-Draft                 JSON Schema                September 2012


   follow the following recommendations:

      in root schemas, "id" SHOULD obey the same constraints as
      described for "location";

      if used in subschemas, "id" SHOULD be a fragment-only URI.

   In any event, implementations SHOULD NOT expect peer implementations
   to support JSON Schema identification by the means of the "id"
   keyword.

6.  JSON Schema referencing

6.1.  Purpose of this section

   JSON Schema referencing is done using JSON Reference (FIXME: link to
   draft).

   In addition, JSON Schema extends the specification so as to use a
   dedicated fragment resolution scheme, by the name "json-schema".
   This mechanism is explained below.  FIXME: RFC for fragment-
   resolution?

6.2.  Determining the URI of a schema

   Implementations SHOULD determine the URI of a schema as follows:

      if the schema was loaded from an absolute URI with no fragment
      part, or an empty fragment part, then the URI of the schema SHOULD
      be considered to be the loading URI, regardless of the values of
      "location" or "id";

      in any other situations:

         if the "location" keyword is present and conforms to this
         specification, the value of this keyword SHOULD be considered
         as the schema URI;

         if the "id" keyword is present and conforms to FIXME:
         crosslink, the value of this keyword MAY be considered as the
         schema URI;

         otherwise, implementations SHOULD choose an arbitrary URN, or
         the empty URI.







Galiegue, et al.         Expires March 19, 2013                 [Page 7]

Internet-Draft                 JSON Schema                September 2012


6.3.  Loading schemas using JSON Reference

   When encountering a JSON Reference, implementations MUST follow the
   rules defined by the JSON Reference draft.  In addition:

      if resolution of the JSON Reference fails, or the dereferenced
      content is not a JSON Schema, it is RECOMMENDED that
      implementations consider this a failure and stop JSON Schema
      processing;

      implementations MUST perform fragment resolution as per the
      mechanism described below.

6.4.  The "json-schema" fragment resolution scheme

   The "json-schema" fragment resolution scheme is an extension to the
   "json-pointer" fragment resolution scheme and works as follows:

      implementations first try and treat this fragment as a JSON
      Pointer; if successful, they try and dereference that pointer
      against the current JSON Schema;

      if the fragment is not a JSON Pointer, implementations try and
      find in the JSON Schema a subschema with a "subId" keyword, which
      value is strictly equal to the fragment's URI-decoded string
      value.

7.  Schema/Instance Association

7.1.  Purpose of this section

   A JSON instance MAY be correlated to one, or even several, JSON
   Schemas.  This correlation MAY be embodied witin existing protocol
   headers.

   In addition, if the protocol also carries media type information (by
   means, for instance, of a "Content-Type" header), an instance MUST be
   one of "application/json" or any other subtype.

   Should the scenario above be inapplicable, due either to the absence
   of, or restrictions on, protocol headers, such a correlation is out
   of the normative scope of this specification.

7.2.  Recommended correlation mechanisms for use with the HTTP protocol

   It is acknowledged by this specification that the majority of
   interactive JSON Schema processing will be over HTTP.  This section
   therefore gives recommendations for materializing an instance/schema



Galiegue, et al.         Expires March 19, 2013                 [Page 8]

Internet-Draft                 JSON Schema                September 2012


   correlation using mechanisms currently available for this protocol.

7.2.1.  Correlation by means of the "Content-Type" header

   It is RECOMMENDED that a MIME type parameter by the name of "profile"
   be appended to the "Content-Type" header of the instance being
   processed.  If present, the value of this parameter MUST be a valid
   URI, and this URI SHOULD resolve to a valid JSON Schema.

   An example of such a header would be:


   Content-Type: application/my-media-type+json;
                 profile=http://example.com/my-hyper-schema


7.2.2.  Correlation by means of the "Link" header

   When using the "Link" header, it is RECOMMENDED that a relationship
   by the name "describedBy" be used, as defined by RFC 2048, section
   19.6.2.4 (FIXME: make real link).  Note: it should be remembered that
   relationship values are case insensitive, so "describedBy" is just as
   valid a relationship as "DESCRIBEDBY".

   The target URI of the "Link" header SHOULD be a valid JSON Schema.

   An example of such a header would be:


   Link: <http://example.com/my-hyper-schema>; rel="describedBy"


8.  IANA Considerations

   The proposed MIME media type for JSON Schema is defined as follows:

      type name: application;

      subtype name: schema+json;

      required parameters: profile.

      FIXME: fragment resolution?

9.  References






Galiegue, et al.         Expires March 19, 2013                 [Page 9]

Internet-Draft                 JSON Schema                September 2012


9.1.  Normative References

   [RFC2119]       Bradner, S., "Key words for use in RFCs to Indicate
                   Requirement Levels", BCP 14, RFC 2119, March 1997.

   [json-pointer]  Bryan, P. and K. Zyp, "JSON Pointer", October 2011, <
                   http://tools.ietf.org/html/
                   draft-ietf-appsawg-json-pointer-04>.

9.2.  Informative References

   [RFC4627]       Crockford, D., "The application/json Media Type for
                   JavaScript Object Notation (JSON)", RFC 4627,
                   July 2006.

Appendix A.  ChangeLog

   TODO

Authors' Addresses

   Francis Galiegue

   EMail: fgaliegue@gmail.com


   Kris Zyp (editor)
   SitePen (USA)
   530 Lytton Avenue
   Palo Alto, CA 94301
   USA

   Phone: +1 650 968 8787
   EMail: kris@sitepen.com


   Gary Court
   Calgary, AB
   Canada

   EMail: gary.court@gmail.com










Galiegue, et al.         Expires March 19, 2013                [Page 10]

