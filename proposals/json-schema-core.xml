<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<rfc category="info" docName="json-schema-core" ipr="trust200902">
    <front>
        <title abbrev="JSON Schema">JSON Schema: core definitions and purposes</title>

        <author fullname="Francis Galiegue" initials="fge" surname="Galiegue">
            <address>
                <email>fgaliegue@gmail.com</email>
            </address>
        </author>

        <author fullname="Kris Zyp" initials="K" role="editor" surname="Zyp">
            <organization>SitePen (USA)</organization>
            <address>
                <postal>
                    <street>530 Lytton Avenue</street>
                    <city>Palo Alto, CA 94301</city>
                    <country>USA</country>
                </postal>
                <phone>+1 650 968 8787</phone>
                <email>kris@sitepen.com</email>
            </address>
        </author>

        <author fullname="Gary Court" initials="G" surname="Court">
            <address>
                <postal>
                    <city>Calgary, AB</city>
                    <country>Canada</country>
                </postal>
                <email>gary.court@gmail.com</email>
            </address>
        </author>

        <date year="2012"/>
        <workgroup>Internet Engineering Task Force</workgroup>
        <keyword>JSON</keyword>
        <keyword>Schema</keyword>
        <keyword>Hyper Schema</keyword>
        <keyword>Hypermedia</keyword>

        <abstract>
            <t>
                JSON Schema defines the media type "application/schema+json", a JSON based format
                for defining the structure of JSON data. JSON Schema provides a contract for what
                JSON data is required for a given application and how to interact with it. JSON
                Schema is intended to define validation, documentation, hyperlink navigation, and
                interaction control of JSON data.
            </t>
        </abstract>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                JSON Schema is a JSON media type for defining the structure of JSON data. JSON
                Schema provides a contract for what JSON data is required for a given application
                and how to interact with it. JSON Schema is intended to define validation,
                documentation, hyperlink navigation, and interaction control of JSON data.
            </t>

            <t>
                This document defines the core terminology used by JSON Schema. Other linked
                specifications, which expand on a particular role of JSON Schema, will use that
                terminology.
            </t>

            <t>
                This document also defines the mechanisms used for JSON Schema identification and
                referencing.
            </t>
        </section>

        <section title="Conventions and Terminology">
            <t>
                <!-- The text in this section has been copied from the official boilerplate,
                and should not be modified.-->

                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
            </t>

            <t>
                The terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array",
                "number", "string", "boolean", "true", "false", and "null" in this document are to
                be interpreted as defined in <xref target="RFC4627">RFC 4627</xref>.
            </t>
        </section>

        <section title="Core terminology of JSON Schema">
            
            <section title="JSON Schema, keywords">
                <t>
                    A JSON Schema is a JSON document, and that document MUST be an object. Object
                    members of a JSON Schema are called keywords, or schema keywords.
                </t>

                <t>
                    A JSON Schema MAY be empty.
                </t>
            </section>

            <section title="Enclosing schema, root schema">
                <t>
                    JSON Schemas can be nested, as in this example:
                </t>
                <figure>
                    <artwork>
<![CDATA[
{
    "title": "root",
    "otherschema": {
        "title": "nested",
        "anotherschema": {
            "title": "alsonested"
        }
    }
}
]]>
                    </artwork>
                </figure>

                <t>
                    In this example, the enclosing schema of both "nested" and "alsonested" is
                    "root". The schema with title "root" is said to be a root schema because it
                    is not enclosed within another schema.
                </t>
            </section>

            <section title="JSON Schema primitive types">
                <t>
                    JSON Schema defines seven primitive types for JSON values:
                </t>

                <list style="hanging">
                    <t hangText="array">A JSON array.</t>
                    <t hangText="boolean">A JSON boolean (true or false).</t>
                    <t hangText="integer">A JSON number without a decimal part.</t>
                    <t hangText="number">Any JSON number. Number includes integer.</t>
                    <t hangText="null">The JSON null value.</t>
                    <t hangText="object">A JSON object.</t>
                    <t hangText="string">A JSON string.</t>
                </list>

            </section>

            <section title="JSON value equality">
                <t>
                    Two JSON values are said to be equal if and only if:
                </t>

                <list>
                    <t>both are nulls; or</t>
                    <t>both are booleans or strings, and have the same value; or</t>
                    <t>both are numbers, and have the same JSON reprensetation; or</t>
                    <t>both are arrays, and:
                        <list>
                            <t>have the same number of elements; and</t>
                            <t>elements at the same index are equal according to this definition;
                            or</t>
                        </list>
                    </t>
                    <t>both are objects, and:
                        <list>
                            <t>have the same set of members; and</t>
                            <t>values for a same member are equal according to this definition.</t>
                        </list>
                    </t>
                </list>
            </section>

            <t>
                Note about numbers: the two JSON number values, 1.0 and 1, for instance, are
                mathematically equivalent; however they are NOT equal, since their JSON
                representation differs.
            </t>

            <section title="Instance">
                <t>
                    An instance is any JSON value being processed by a JSON Schema. The
                    specification may also refer to an instance as a JSON instance.
                </t>
            </section>

        </section>

        <section title="Overview">
            <t>
                JSON Schema defines the media type "application/schema+json" for describing the
                structure of JSON instances. JSON Schemas are themselves written in JSON and include
                facilities for describing the structure of JSON in terms of allowable values,
                descriptions, and interpreting relations with other resources.
            </t>

            <t>
                JSON Schema serves different purposes, which are summarized below. Each purpose has
                a defined set of keywords which is described in its own specification.
            </t>

            <list style="hanging">
                <t hangText="Documentation">JSON Schema can be used to decorate either itself, or
                instances, with descriptive text highlighting the schema's, or instance's,
                purposes.</t>
                <t hangText="Hyperlinking">JSON Schema can be used to associate an instance to a
                Link Description Object, as defined by FIXME.</t>
                <t hangText="Validation">JSON Schema can be used to validate the structure of an
                instance. Keywords also exist for semantic analysis, although implementations are
                not required to implement them.</t>
            </list>

            <section title="Design Considerations">
                <t>
                    JSON Schema provides a separate format for flexibly communicating how a JSON
                    value should be interpreted and/or validated, such that clients can properly
                    understand acceptable structures for, and/or extract the needed information
                    from, the JSON instance being processed.
                </t>
                <t>
                    It is acknowledged that JSON values can be of any type defined by the JSON
                    specification. As such, JSON Schema does not mandate that an instance be of a
                    particular type: JSON Schema can process any JSON value, including null. It is
                    the domain of JSON Schema validation to add useful constraints to the structure
                    and, optionally, semantics, of the JSON instance being processed.
                </t>
                <t>
                    JSON Schema is agnostic with regards to both protocols and programming
                    languages. In particular, this means that defining the semantics of the
                    client-server interface is dependent on the protocol being used.
                </t>
            </section>
        </section>

        <section title="JSON Schema identification">

            <section title="Purpose of this section">
                <t>
                    This section describes the available mechanisms for identifying the schema in a
                    unique way: its location, but also the version of the JSON Schema specification
                    it is written against.
                </t>
            </section>

            <section title="Meta-schema identification using $schema">
                <t>
                    TODO -- core schema, hyper schema, etc etc...
                </t>
            </section>

            <section title="Root schema identification">
                <t>
                    A root schema MAY be uniquely identified by the presence of a "location"
                    keyword. This keyword's value MUST be a string, and this string MUST be a URI;
                    the URI MUST be absolute, and MUST have either no fragment, or an empty
                    fragment.
                </t>

                <t>
                    This keyword MUST NOT be used in subschemas.
                </t>

            </section>

            <section title="Subschema identification">
                <t>
                    Within JSON Schemas, a subschema MAY be identified by the presence of a "subId"
                    keyword. This keyword's value MUST be a string.
                </t>

                <t>
                    This string MUST NOT be empty. It MUST NOT start with a solidus (/). A same
                    string MUST NOT be used more than once in a same root schema.
                </t>

                <t>
                    This keyword MAY also be used in a root schema.
                </t>
            </section>

            <section title='Identification using \"id\"'>

                <t>
                    The value for this keyword MUST be a string. This string MUST be a URI.
                </t>

                <t>
                    For backwards compatibility, JSON Schemas MAY use the "id" keyword for
                    identification purposes. However, due to numerous ambiguity concerns, this is
                    NOT RECOMMENDED.
                </t>

                <t>
                    Schema authors willing to use "id" for identification purposes SHOULD follow the
                    following recommendations:
                </t>
                
                <list>
                    <t>in root schemas, "id" SHOULD obey the same constraints as described for
                    "location";</t>
                    <t>if used in subschemas, "id" SHOULD be a fragment-only URI.</t>
                </list>

                <t>
                    In any event, implementations SHOULD NOT expect peer implementations to support
                    JSON Schema identification by the means of the "id" keyword.
                </t>
            </section>

        </section>

        <section title="JSON Schema referencing">

            <section title="Purpose of this section">
                <t>
                    JSON Schema referencing is done using JSON Reference (FIXME: link to draft).
                </t>

                <t>
                    In addition, JSON Schema extends the specification so as to use a dedicated
                    fragment resolution scheme, by the name "json-schema". This mechanism is
                    explained below. FIXME: RFC for fragment-resolution?
                </t>
            </section>

            <section title="Determining the URI of a schema">

                <t>
                    Implementations SHOULD determine the URI of a schema as follows:
                </t>

                <list>
                    <t>if the schema was loaded from an absolute URI with no fragment part, or an
                    empty fragment part, then the URI of the schema SHOULD be considered to be the
                    loading URI, regardless of the values of "location" or "id";</t>
                    <t>in any other situations:
                        <list>
                            <t>if the "location" keyword is present and conforms to this
                            specification, the value of this keyword SHOULD be considered as the
                            schema URI;</t>
                            <t>if the "id" keyword is present and conforms to FIXME: crosslink, the
                            value of this keyword MAY be considered as the schema URI;</t>
                            <t>otherwise, implementations SHOULD choose an arbitrary URN, or the
                            empty URI.</t>
                        </list>
                    </t>
                </list>

            </section>

            <section title="Loading schemas using JSON Reference">
                <t>
                    When encountering a JSON Reference, implementations MUST follow the rules
                    defined by the JSON Reference draft. In addition:
                </t>

                <list>
                    <t>if resolution of the JSON Reference fails, or the dereferenced content is not
                    a JSON Schema, it is RECOMMENDED that implementations consider this a failure
                    and stop JSON Schema processing;</t>
                    <t>implementations MUST perform fragment resolution as per the mechanism
                    described below.</t>
                </list>
            </section>

            <section title='The "json-schema" fragment resolution scheme'>
                <t>
                    The "json-schema" fragment resolution scheme is an extension to the
                    "json-pointer" fragment resolution scheme and works as follows:
                </t>

                <list>
                    <t>implementations first try and treat this fragment as a JSON Pointer; if
                    successful, they try and dereference that pointer against the current JSON
                    Schema;</t>
                    <t>if the fragment is not a JSON Pointer, implementations try and find in the
                    JSON Schema a subschema with a "subId" keyword, which value is strictly equal to
                    the fragment's URI-decoded string value.</t>
                </list>
            </section>
        </section>
        <section title="Schema/Instance Association">

            <section title="Purpose of this section">
                <t>
                    A JSON instance MAY be correlated to one, or even several, JSON Schemas. This
                    correlation MAY be embodied witin existing protocol headers.
                </t>

                <t>
                    In addition, if the protocol also carries media type information (by means, for
                    instance, of a "Content-Type" header), an instance MUST be one of
                    "application/json" or any other subtype.
                </t>

                <t>
                    Should the scenario above be inapplicable, due either to the absence of, or
                    restrictions on, protocol headers, such a correlation is out of the normative
                    scope of this specification.
                </t>
            </section>

            <section title="Recommended correlation mechanisms for use with the HTTP protocol">

                <t>
                    It is acknowledged by this specification that the majority of interactive JSON
                    Schema processing will be over HTTP. This section therefore gives
                    recommendations for materializing an instance/schema correlation using
                    mechanisms currently available for this protocol.
                </t>

                <section title='Correlation by means of the "Content-Type" header'>
                    <t>
                        It is RECOMMENDED that a MIME type parameter by the name of "profile" be
                        appended to the "Content-Type" header of the instance being processed. If
                        present, the value of this parameter MUST be a valid URI, and this URI
                        SHOULD resolve to a valid JSON Schema.
                    </t>

                    <t>
                        An example of such a header would be:
                    </t>
                      
                    <figure>
                        <artwork>
<![CDATA[
Content-Type: application/my-media-type+json;
              profile=http://example.com/my-hyper-schema
]]>
                        </artwork>
                    </figure>

                </section>

                <section title='Correlation by means of the "Link" header'>
                    <t>
                        When using the "Link" header, it is RECOMMENDED that a relationship by the
                        name "describedBy" be used, as defined by RFC 2048, section 19.6.2.4 (FIXME:
                        make real link). Note: it should be remembered that relationship values are
                        case insensitive, so "describedBy" is just as valid a relationship as
                        "DESCRIBEDBY".
                    </t>

                    <t>
                        The target URI of the "Link" header SHOULD be a valid JSON Schema.
                    </t>

                    <t>
                        An example of such a header would be:
                    </t>

                    <figure>
                        <artwork>
<![CDATA[
Link: <http://example.com/my-hyper-schema>; rel="describedBy"
]]>
                        </artwork>
                    </figure>

                </section>
            </section>

        </section>

        <section title="IANA Considerations">
            <t>
                The proposed MIME media type for JSON Schema is defined as follows:
            </t>

            <list>
                <t>type name: application;</t>
                <t>subtype name: schema+json;</t>
                <t>required parameters: profile.</t>
                <t>FIXME: fragment resolution?</t>
            </list>

        </section>
    </middle>

    <back>
        <!-- References Section -->
        <references title="Normative References">
            &RFC2119;
            <reference anchor="json-pointer"
                target="http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-04">
                <front>
                    <title>JSON Pointer</title>
                    <author initials="P." surname="Bryan">
                        <organization>ForgeRock US, Inc.</organization>
                    </author>
                    <author initials="K." surname="Zyp">
                        <organization>SitePen (USA)</organization>
                    </author>
                    <date year="2011" month="October" />
                </front>
            </reference>
        </references>
        <references title="Informative References">
            &RFC4627;
        </references>

        <section title="ChangeLog">
            <t>TODO</t>
            <!--
            <t>
                <list style="hanging">
                    <t hangText="draft-04">
                        <list style="symbols">
                            <t>Changed "required" attribute to an array of strings.</t>
                            <t>Removed "format" attribute.</t>
                            <t>Added "minProperties" and "maxProperties" attributes.</t>
                            <t>Replaced "slash-delimited" fragment resolution with
                            "json-pointer".</t>
                            <t>Added "template" LDO attribute.</t>
                            <t>Removed irrelevant "Open Issues" section.</t>
                            <t>Merged Conventions and Terminology sections.</t>
                            <t>Defined terms used in specification.</t>
                            <t>Restricted "type" to only the core JSON types.</t>
                            <t>Renamed "divisibleBy" to "mod".</t>
                            <t>Improved wording of many sections.</t>
                        </list>
                    </t>

                    <t hangText="draft-03">
                        <list style="symbols">
                            <t>Added example and verbiage to "extends" attribute.</t>
                            <t>Defined slash-delimited to use a leading slash.</t>
                            <t>Made "root" a relation instead of an attribute.</t>
                            <t>Removed address values, and MIME media type from format to reduce
                            confusion (mediaType already exists, so it can be used for MIME
                            types).</t>
                            <t>Added more explanation of nullability.</t>
                            <t>Removed "alternate" attribute.</t>
                            <t>Upper cased many normative usages of must, may, and should.</t>
                            <t>Replaced the link submission "properties" attribute to "schema"
                            attribute.</t>
                            <t>Replaced "optional" attribute with "required" attribute.</t>
                            <t>Replaced "maximumCanEqual" attribute with "exclusiveMaximum"
                            attribute.</t>
                            <t>Replaced "minimumCanEqual" attribute with "exclusiveMinimum"
                            attribute.</t>
                            <t>Replaced "requires" attribute with "dependencies" attribute.</t>
                            <t>Moved "contentEncoding" attribute to hyper schema.</t>
                            <t>Added "additionalItems" attribute.</t>
                            <t>Added "id" attribute.</t>
                            <t>Switched self-referencing variable substitution from "-this" to "@"
                            to align with reserved characters in URI template.</t>
                            <t>Added "patternProperties" attribute.</t>
                            <t>Schema URIs are now namespace versioned.</t>
                            <t>Added "$ref" and "$schema" attributes.</t>
                        </list>
                    </t>

                    <t hangText="draft-02">
                        <list style="symbols">
                            <t>Replaced "maxDecimal" attribute with "divisibleBy" attribute.</t>
                            <t>Added slash-delimited fragment resolution protocol and made it the
                            default.</t>
                            <t>Added language about using links outside of schemas by referencing
                            its normative URI.</t>
                            <t>Added "uniqueItems" attribute.</t>
                            <t>Added "targetSchema" attribute to link description object.</t>
                        </list>
                    </t>

                    <t hangText="draft-01">
                        <list style="symbols">
                            <t>Fixed category and updates from template.</t>
                        </list>
                    </t>

                    <t hangText="draft-00">
                        <list style="symbols">
                            <t>Initial draft.</t>
                        </list>
                    </t>
                </list>
            </t>
            -->
        </section>
    </back>
</rfc>
