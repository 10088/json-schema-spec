<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<rfc category="info" docName="json-schema-core" ipr="trust200902">
    <front>
        <title abbrev="JSON Schema">JSON Schema: core definitions and purposes</title>

        <author fullname="Francis Galiegue" initials="fge" surname="Galiegue">
            <address>
                <email>fgaliegue@gmail.com</email>
            </address>
        </author>

        <author fullname="Kris Zyp" initials="K" role="editor" surname="Zyp">
            <organization>SitePen (USA)</organization>
            <address>
                <postal>
                    <street>530 Lytton Avenue</street>
                    <city>Palo Alto, CA 94301</city>
                    <country>USA</country>
                </postal>
                <phone>+1 650 968 8787</phone>
                <email>kris@sitepen.com</email>
            </address>
        </author>

        <author fullname="Gary Court" initials="G" surname="Court">
            <address>
                <postal>
                    <city>Calgary, AB</city>
                    <country>Canada</country>
                </postal>
                <email>gary.court@gmail.com</email>
            </address>
        </author>

        <date year="2012"/>
        <workgroup>Internet Engineering Task Force</workgroup>
        <keyword>JSON</keyword>
        <keyword>Schema</keyword>
        <keyword>Hyper Schema</keyword>
        <keyword>Hypermedia</keyword>

        <abstract>
            <t>
                JSON Schema defines the media type "application/schema+json", a JSON based format
                for defining the structure of JSON data. JSON Schema provides a contract for what
                JSON data is required for a given application and how to interact with it. JSON
                Schema is intended to define validation, documentation, hyperlink navigation, and
                interaction control of JSON data.
            </t>
        </abstract>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                JSON Schema is a JSON media type for defining the structure of JSON data. JSON
                Schema provides a contract for what JSON data is required for a given application
                and how to interact with it. JSON Schema is intended to define validation,
                documentation, hyperlink navigation, and interaction control of JSON data.
            </t>

            <t>
                This document defines the core terminology used by JSON Schema. Other linked
                specifications, which expand on a particular role of JSON Schema, will use that
                terminology.
            </t>

            <t>
                This document also defines the mechanisms used for JSON Schema identification and
                referencing.
            </t>
        </section>

        <section title="Conventions and Terminology">
            <t>
                <!-- The text in this section has been copied from the official boilerplate,
                and should not be modified.-->

                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
            </t>

            <t>
                The terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array",
                "number", "string", "boolean", "true", "false", and "null" in this document are to
                be interpreted as defined in <xref target="RFC4627">RFC 4627</xref>.
            </t>
        </section>

        <section title="Core terminology of JSON Schema">
            
            <section title="JSON Schema, keywords">
                <t>
                    A JSON Schema is a JSON document, and that document MUST be an object. Object
                    members of a JSON Schema are called keywords, or schema keywords.
                </t>

                <t>
                    A JSON Schema MAY be empty.
                </t>
            </section>

            <section title="Enclosing schema, root schema">
                <t>
                    JSON Schemas can be nested, as in this example:
                </t>
                <figure>
                    <artwork>
<![CDATA[
{
    "title": "root",
    "otherschema": {
        "title": "nested",
        "anotherschema": {
            "title": "alsonested"
        }
    }
}
]]>
                    </artwork>
                </figure>

                <t>
                    In this example, the enclosing schema of both "nested" and "alsonested" is
                    "root". The schema with title "root" is said to be a root schema because it
                    is not enclosed within another schema. The enclosing schema of a root schema is
                    itself.
                </t>
            </section>

            <section title="JSON Schema primitive types">
                <t>
                    JSON Schema defines seven primitive types for JSON values:
                </t>

                <list style="hanging">
                    <t hangText="array">A JSON array.</t>
                    <t hangText="boolean">A JSON boolean (true or false).</t>
                    <t hangText="integer">A JSON number without a decimal part.</t>
                    <t hangText="number">Any JSON number. Number includes integer.</t>
                    <t hangText="null">The JSON null value.</t>
                    <t hangText="object">A JSON object.</t>
                    <t hangText="string">A JSON string.</t>
                </list>

            </section>

            <section title="JSON value equality">
                <t>
                    Two JSON values are said to be equal if and only if:
                </t>

                <list>
                    <t>both are nulls; or</t>
                    <t>both are booleans or strings, and have the same value; or</t>
                    <t>both are numbers, and have the same JSON reprensetation; or</t>
                    <t>both are arrays, and:
                        <list>
                            <t>have the same number of elements; and</t>
                            <t>elements at the same index are equal according to this definition;
                            or</t>
                        </list>
                    </t>
                    <t>both are objects, and:
                        <list>
                            <t>have the same set of members; and</t>
                            <t>values for a same member are equal according to this definition.</t>
                        </list>
                    </t>
                </list>
            </section>

            <t>
                Note about numbers: the two JSON number values, 1.0 and 1, for instance, are
                mathematically equivalent; however they are NOT equal, since their JSON
                representation differs.
            </t>

            <section title="Instance">
                <t>
                    An instance is any JSON value being processed by a JSON Schema. The
                    specification may also refer to an instance as a JSON instance.
                </t>
            </section>

        </section>

        <section title="Overview">
            <t>
                JSON Schema defines the media type "application/schema+json" for describing the
                structure of JSON instances. JSON Schemas are themselves written in JSON and include
                facilities for describing the structure of JSON in terms of allowable values,
                descriptions, and interpreting relations with other resources.
            </t>

            <t>
                JSON Schema serves different purposes, which are summarized below. Each purpose has
                a defined set of keywords which is described in its own specification.
            </t>

            <list style="hanging">
                <t hangText="Documentation">JSON Schema can be used to decorate either itself, or
                instances, with descriptive text highlighting the schema's, or instance's,
                purposes.</t>
                <!-- FIXME: there is a suggestion for hypermedia instead of hyperlinking -->
                <t hangText="Hyperlinking">JSON Schema can be used to associate an instance to a
                Link Description Object, as defined by FIXME.</t>
                <t hangText="Validation">JSON Schema can be used to validate the structure of an
                instance. Keywords also exist for semantic analysis, although implementations are
                not required to implement them.</t>
            </list>

            <section title="Design Considerations">
                <t>
                    JSON Schema provides a separate format for flexibly communicating how a JSON
                    value should be interpreted and/or validated, such that clients can properly
                    understand acceptable structures for, and/or extract the needed information
                    from, the JSON instance being processed. This information ranges from
                    documentation to external resource links, and processing of these links.
                </t>
                <t>
                    It is acknowledged that JSON values can be of any type defined by the JSON
                    specification. As such, JSON Schema does not mandate that an instance be of a
                    particular type: JSON Schema can process any JSON value, including null. It is
                    the domain of JSON Schema validation to add useful constraints to the structure
                    and, optionally, semantics, of the JSON instance being processed.
                </t>
                <t>
                    JSON Schema is agnostic with regards to both protocols and programming
                    languages. In particular, this means that defining the semantics of the
                    client-server interface is dependent on the protocol being used.
                </t>
            </section>
        </section>

        <section title='Schema identification: the "id" keyword'>

            <section title="Usage">
                <t>
                    Schema authors MAY choose to use the "id" keyword to add identification
                    information to a JSON Schema.  The value of this keyword MUST be a string, and
                    this string MUST be a valid URI. The URI MUST be normalized.
                </t>

                <t>
                    When used in a root schema, the URI SHOULD be absolute and have no, or an empty,
                    fragment part. Failing that, an implementation MAY choose to ignore the "id"
                    value. It is RECOMMENDED that when used in subschemas, the URI be relative. In
                    subschemas, "id" MUST NOT be the empty fragment ("#").
                </t>

                <t>
                    In a same schema, there SHOULD NOT be two equivalent "id" values. Failing that,
                    as JSON objects do not define an order for members, URI resolution is undefined.
                </t>

                <t>
                    Implementations MUST consider that a URI with no fragment part is equivalent to
                    this same URI with an empty fragment part.
                </t>

            </section>

            <section title="Inner schema addressing">
                <t>
                    When "id" is encountered in a subschema, implementations MAY resolve this URI
                    against the root schema's URI, and consider that the canonical URI of this
                    subschema is the calculated URI. This is called inner schema addressing.
                </t>

                <figure>
                    <preamble>This schema will be taken as an example:</preamble>
                    <artwork>
                    <!-- FIXME: http again as a scheme, maybe another one? It can be any scheme
                    after all -->
<![CDATA[
{
    "id": "http://x.y.z/rootschema.json#",
    "schema1": {
        "id": "#foo"
    },
    "schema2": {
        "id": "otherschema.json",
        "nested": {
            "id": "#bar"
        },
        "alsonested": {
            "id": t/inner.json#a"
        }
    }
}
]]>
                    </artwork>
                </figure>
                
                <t>
                    Subschemas at the following URI-encoded JSON Pointers (starting from the root of
                    the schema) have the following URIs:
                </t>

                <list style="hanging">
                    <t hangtext="# (document root)">http://x.y.z/rootschema.json#</t>
                    <t hangtext="#/schema1">http://x.y.z/rootschema.json#foo</t>
                    <t hangtext="#/schema2">http://x.y.z/otherschema.json#</t>
                    <t hangtext="#/schema2/nested">http://x.y.z/rootschema.json#bar</t>
                    <t hangtext="#/schema2/alsonested">http://x.y.z/t/inner.json#a</t>
                </list>

            </section>

            <section title="Security considerations">
                <t>
                    Inner schema addressing can produce canonical URIs which differ from the
                    canonical URI of the root schema. Implementations therefore MAY choose, for
                    security reasons, to ignore inner schema addressing, and always dereference
                    canonical URIs.
                </t>

                <t>
                    As such, schema authors SHALL NOT expect that inner schema addressing be used by
                    an implementation.
                </t>
            </section>
        </section>

        <section title="Schema/Instance Association">

            <section title="Purpose of this section">
                <t>
                    A JSON instance MAY be correlated to one, or even several, JSON Schemas. This
                    correlation MAY be embodied witin existing protocol headers.
                </t>

                <t>
                    In addition, if the protocol also carries media type information (by means, for
                    instance, of a "Content-Type" header), an instance MUST be one of
                    "application/json" or any other subtype.
                </t>

                <t>
                    Should the scenario above be inapplicable, due either to the absence of, or
                    restrictions on, protocol headers, such a correlation is out of the normative
                    scope of this specification.
                </t>
            </section>

            <section title="Recommended correlation mechanisms for use with the HTTP protocol">

                <t>
                    It is acknowledged by this specification that the majority of interactive JSON
                    Schema processing will be over HTTP. This section therefore gives
                    recommendations for materializing an instance/schema correlation using
                    mechanisms currently available for this protocol.
                </t>

                <section title='Correlation by means of the "Content-Type" header'>
                    <t>
                        It is RECOMMENDED that a MIME type parameter by the name of "profile" be
                        appended to the "Content-Type" header of the instance being processed. If
                        present, the value of this parameter MUST be a valid URI, and this URI
                        SHOULD resolve to a valid JSON Schema.
                    </t>

                    <t>
                        An example of such a header would be:
                    </t>
                      
                    <figure>
                        <artwork>
<![CDATA[
Content-Type: application/my-media-type+json;
              profile=http://example.com/my-hyper-schema
]]>
                        </artwork>
                    </figure>

                </section>

                <section title='Correlation by means of the "Link" header'>
                    <t>
                        When using the "Link" header, it is RECOMMENDED that a relationship by the
                        name "describedBy" be used, as defined by RFC 2048, section 19.6.2.4 (FIXME:
                        make real link). Note: it should be remembered that relationship values are
                        case insensitive, so "describedBy" is just as valid a relationship as
                        "DESCRIBEDBY".
                    </t>

                    <t>
                        The target URI of the "Link" header SHOULD be a valid JSON Schema.
                    </t>

                    <t>
                        An example of such a header would be:
                    </t>

                    <figure>
                        <artwork>
<![CDATA[
Link: <http://example.com/my-hyper-schema>; rel="describedBy"
]]>
                        </artwork>
                    </figure>

                </section>
            </section>

        </section>

        <section title="IANA Considerations">
            <t>
                The proposed MIME media type for JSON Schema is defined as follows:
            </t>

            <list>
                <t>type name: application;</t>
                <t>subtype name: schema+json;</t>
                <t>required parameters: profile.</t>
                <t>FIXME: fragment resolution?</t>
            </list>

        </section>
    </middle>

    <back>
        <!-- References Section -->
        <references title="Normative References">
            &RFC2119;
            <reference anchor="json-pointer"
                target="http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-04">
                <front>
                    <title>JSON Pointer</title>
                    <author initials="P." surname="Bryan">
                        <organization>ForgeRock US, Inc.</organization>
                    </author>
                    <author initials="K." surname="Zyp">
                        <organization>SitePen (USA)</organization>
                    </author>
                    <date year="2011" month="October" />
                </front>
            </reference>
        </references>
        <references title="Informative References">
            &RFC4627;
        </references>

        <section title="ChangeLog">
            <t>TODO</t>
            <!--
            <t>
                <list style="hanging">
                    <t hangText="draft-04">
                        <list style="symbols">
                            <t>Changed "required" attribute to an array of strings.</t>
                            <t>Removed "format" attribute.</t>
                            <t>Added "minProperties" and "maxProperties" attributes.</t>
                            <t>Replaced "slash-delimited" fragment resolution with
                            "json-pointer".</t>
                            <t>Added "template" LDO attribute.</t>
                            <t>Removed irrelevant "Open Issues" section.</t>
                            <t>Merged Conventions and Terminology sections.</t>
                            <t>Defined terms used in specification.</t>
                            <t>Restricted "type" to only the core JSON types.</t>
                            <t>Renamed "divisibleBy" to "mod".</t>
                            <t>Improved wording of many sections.</t>
                        </list>
                    </t>

                    <t hangText="draft-03">
                        <list style="symbols">
                            <t>Added example and verbiage to "extends" attribute.</t>
                            <t>Defined slash-delimited to use a leading slash.</t>
                            <t>Made "root" a relation instead of an attribute.</t>
                            <t>Removed address values, and MIME media type from format to reduce
                            confusion (mediaType already exists, so it can be used for MIME
                            types).</t>
                            <t>Added more explanation of nullability.</t>
                            <t>Removed "alternate" attribute.</t>
                            <t>Upper cased many normative usages of must, may, and should.</t>
                            <t>Replaced the link submission "properties" attribute to "schema"
                            attribute.</t>
                            <t>Replaced "optional" attribute with "required" attribute.</t>
                            <t>Replaced "maximumCanEqual" attribute with "exclusiveMaximum"
                            attribute.</t>
                            <t>Replaced "minimumCanEqual" attribute with "exclusiveMinimum"
                            attribute.</t>
                            <t>Replaced "requires" attribute with "dependencies" attribute.</t>
                            <t>Moved "contentEncoding" attribute to hyper schema.</t>
                            <t>Added "additionalItems" attribute.</t>
                            <t>Added "id" attribute.</t>
                            <t>Switched self-referencing variable substitution from "-this" to "@"
                            to align with reserved characters in URI template.</t>
                            <t>Added "patternProperties" attribute.</t>
                            <t>Schema URIs are now namespace versioned.</t>
                            <t>Added "$ref" and "$schema" attributes.</t>
                        </list>
                    </t>

                    <t hangText="draft-02">
                        <list style="symbols">
                            <t>Replaced "maxDecimal" attribute with "divisibleBy" attribute.</t>
                            <t>Added slash-delimited fragment resolution protocol and made it the
                            default.</t>
                            <t>Added language about using links outside of schemas by referencing
                            its normative URI.</t>
                            <t>Added "uniqueItems" attribute.</t>
                            <t>Added "targetSchema" attribute to link description object.</t>
                        </list>
                    </t>

                    <t hangText="draft-01">
                        <list style="symbols">
                            <t>Fixed category and updates from template.</t>
                        </list>
                    </t>

                    <t hangText="draft-00">
                        <list style="symbols">
                            <t>Initial draft.</t>
                        </list>
                    </t>
                </list>
            </t>
            -->
        </section>
    </back>
</rfc>
