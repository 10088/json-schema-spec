<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<rfc category="info" docName="json-schema-core" ipr="trust200902">
    <front>
        <title abbrev="JSON Schema">JSON Schema: core definitions and purposes</title>

        <author fullname="Francis Galiegue" initials="fge" surname="Galiegue">
            <address>
                <email>fgaliegue@gmail.com</email>
            </address>
        </author>

        <author fullname="Kris Zyp" initials="K" role="editor" surname="Zyp">
            <organization>SitePen (USA)</organization>
            <address>
                <postal>
                    <street>530 Lytton Avenue</street>
                    <city>Palo Alto, CA 94301</city>
                    <country>USA</country>
                </postal>
                <phone>+1 650 968 8787</phone>
                <email>kris@sitepen.com</email>
            </address>
        </author>

        <author fullname="Gary Court" initials="G" surname="Court">
            <address>
                <email>gary.court@gmail.com</email>
            </address>
        </author>

        <date year="2012"/>
        <workgroup>Internet Engineering Task Force</workgroup>
        <keyword>JSON</keyword>
        <keyword>Schema</keyword>
        <keyword>Hyper Schema</keyword>
        <keyword>Hypermedia</keyword>

        <abstract>
            <t>
                JSON Schema defines the media type "application/schema+json", a JSON based format
                for defining the structure of JSON data. JSON Schema provides a contract for what
                JSON data is required for a given application and how to interact with it. JSON
                Schema is intended to define validation, documentation, hyperlink navigation, and
                interaction control of JSON data.
            </t>
        </abstract>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                JSON Schema is a JSON media type for defining the structure of JSON data. JSON
                Schema provides a contract for what JSON data is required for a given application
                and how to interact with it. JSON Schema is intended to define validation,
                documentation, hyperlink navigation, and interaction control of JSON data.
            </t>

            <t>
                This document defines the core terminology used by JSON Schema. Other linked
                specifications, which expand on a particular role of JSON Schema, will use that
                terminology.
            </t>

            <t>
                This document also defines the mechanisms used for JSON Schema identification and
                referencing.
            </t>
        </section>

        <section title="Conventions and Terminology">
            <t>
                <!-- The text in this section has been copied from the official boilerplate,
                and should not be modified.-->

                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
            </t>

            <t>
                The terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array",
                "number", "string", "boolean", "true", "false", and "null" in this document are to
                be interpreted as defined in <xref target="RFC4627">RFC 4627</xref>.
            </t>
        </section>

        <section title="Core terminology of JSON Schema">
            
            <section title="JSON Schema, keywords">
                <t>
                    A JSON Schema is a JSON document, and that document MUST be an object. Object
                    members of a JSON Schema are called keywords, or schema keywords.
                </t>

                <t>
                    A JSON Schema MAY be empty.
                </t>
            </section>

            <section title="Root schema, subschema">
                <t>
                    JSON Schemas can be nested, as in this example:
                </t>
                <figure>
                    <artwork>
<![CDATA[
{
    "title": "root",
    "otherschema": {
        "title": "nested",
        "anotherschema": {
            "title": "alsonested"
        }
    }
}
]]>
                    </artwork>
                </figure>

                <t>
                    In this example, "nested" and "alsonested" are subschemas, and "root" is a root
                    schema.
                </t>
            </section>

            <section title="JSON Schema primitive types">
                <t>
                    JSON Schema defines seven primitive types for JSON values:
                    <list style="hanging">
                        <t hangText="array">A JSON array.</t>
                        <t hangText="boolean">A JSON boolean (true or false).</t>
                        <t hangText="integer">A JSON number without a decimal or exponent part (see
                        <xref target="RFC4627">RFC 4627, section 2.4</xref>.</t>
                        <t hangText="number">Any JSON number. Number includes integer.</t>
                        <t hangText="null">The JSON null value.</t>
                        <t hangText="object">A JSON object.</t>
                        <t hangText="string">A JSON string.</t>
                    </list>
                </t>
            </section>

            <section title="JSON value equality">
                <t>
                    Two JSON values are said to be equal if and only if:

                    <list>
                        <t>both are nulls; or</t>
                        <t>both are booleans, and have the same value; or</t>
                        <t>both are strings, and have the same value; or</t>
                        <t>both are numbers, and have the same JSON representation; or</t>
                        <t>both are arrays, and:
                            <list>
                                <t>have the same number of elements; and</t>
                                <t>elements at the same index are equal according to this
                                definition; or</t>
                            </list>
                        </t>
                        <t>both are objects, and:
                            <list>
                                <t>have the same set of members; and</t>
                                <t>values for a same member are equal according to this
                                definition.</t>
                            </list>
                        </t>
                    </list>
                </t>
            </section>

            <section title="Instance">
                <t>
                    An instance is any JSON value being processed by a JSON Schema. The
                    specification may also refer to an instance as a JSON instance.
                </t>
            </section>

        </section>

        <section title="Overview">
            <t>
                JSON Schema defines the media type "application/schema+json" for describing the
                structure of JSON instances. JSON Schemas are themselves written in JSON and include
                facilities for describing the structure of JSON in terms of allowable values,
                descriptions, and interpreting relations with other resources.
            </t>

            <t>
                JSON Schema serves different purposes, which are summarized below. Each purpose has
                a defined set of keywords which is described in its own specification.
            </t>

            <section title="Instance validation">
                <t>
                    JSON Schema allows applications to validate any JSON instance, either
                    noninteractively or interactively. For instance, an application may use an
                    external service to collect JSON instances and check that these collected
                    instances match its requirements against a given schema; another application may
                    use a schema to build an interactve interface in order to collect user input,
                    and check the correctness of said input.
                </t>
            </section>

            <section title="Hyperlinking">
                <t>
                    JSON Schema defines a mechanism to build links to a variety of resources. FIXME:
                    describe it better.
                </t>
            </section>
        </section>

        <section title="Design discussion">

            <section title="Generic considerations">
                <t>
                    It is acknowledged that JSON values can be of any type defined by the JSON
                    specification. As such, JSON Schema does not mandate that an instance be of a
                    particular type: JSON Schema can process any JSON value, including null. It is
                    the domain of JSON Schema validation to add useful constraints to the structure
                    and, optionally, semantics, of the JSON instance being processed.
                </t>
                
                <t>
                    JSON Schema is agnostic with regards to both protocols and programming
                    languages. In particular, the semantics of the client-server interface is
                    dependent on the protocol being used. This specification nevertheless suggests
                    mechanisms to correlate an instance to a schema over HTTP, which is the dominant
                    protocol used for Internet-enabled interactive applications.
                </t>
            </section>

            <section title='The "$schema" keyword'>
                <section title="Purpose">
                    <t>
                        The "$schema" keyword plays two roles in JSON Schema:

                        <list>
                            <t>it defines the version of the schema which a particular JSON Schema
                            is valid against;</t>
                            <t>it is a URI which is a location to a JSON Schema which validates any
                            schema written for this version.</t>
                        </list>
                    </t>

                    <t>
                        Any of these schemas also validate themselves successfully.
                    </t>
                </section>

                <section title="Valid values">
                    <t>
                        The value of this keyword MUST be one of the following string values:

                        <list>
                            <t>"http://json-schema.org/draft-03/schema#" (core JSON Schema written
                            against <xref target="json-schema-03">JSON Schema, draft v3</xref>);</t>
                            <t>"http://json-schema.org/draft-03/hyper-schema#" (JSON Schema
                            hyperschema written against <xref target="json-schema-03">JSON Schema,
                            draft v3</xref>);</t>
                            <t>"http://json-schema.org/current/schema-core.json#" (schema written
                            against the current version of the specification -- this one).</t>
                        </list>
                    </t>
                </section>

                <section title="Usage">
                    <t>
                        It is RECOMMENDED that schema authors include this keyword in their schemas.
                        This keyword MUST be located at the root of a schema.
                    </t>

                    <t>
                        It is RECOMMENDED that implementations not supporting a particular schema
                        version fail JSON Schema processing.
                    </t>
                </section>
            </section>

            <section title="Extending JSON Schema">
                <t>
                    Implementations MAY choose to define additional keywords to JSON Schema. Save
                    for explicit agreement, schema authors SHALL NOT expect these additional
                    keywords to be supported by peer implementations.
                </t>
            </section>
        </section>

        <section title="Schema addressing">

            <section title="Addressing mechanisms and general considerations">
                <t>
                    JSON Schema addressing is done using <xref target="RFC3986">URIs</xref>. Two
                    addressing mechanisms are defined: canonical addressing and inner schema
                    addressing. Implementations MUST support canonical addressing, and MAY support
                    inner schema addressing.
                </t>

                <t>
                    Inner schema addressing is done by the means of the "id" keyword. The value of
                    this keyword MUST be a string; this string MUST be a valid URI, and SHOULD be
                    normalized.
                </t>
            </section>

            <section title="URI of a root schema">
                <t>
                    When a schema is loaded via a URI, the loading URI SHALL be considered to be the
                    URI for this schema. If a schema is loaded without a URI:

                    <list>
                        <t>if "id" is present in the root schema, its value MAY be considered to be
                        the schema URI;</t>
                        <t>otherwise, it is RECOMMENDED that implementations consider that the URI
                        of the schema is either the empty URI, or a URN.</t>
                    </list>
                </t>
            </section>

            <section title="Canonical addressing">
                <t>
                    Canonical addressing in JSON Schema is done using <xref
                    target="json-reference">JSON Reference</xref>. JSON References, when
                    encountered, MUST be resolved against the root schema URI before being
                    processed.
                </t>
            </section>

            <section title="Inner schema addressing">
                <t>
                    When "id" is encountered in a subschema, implementations MAY resolve this URI
                    against the root schema's URI, and consider that the canonical URI of this
                    subschema is the calculated URI. This is called inner schema addressing.
                </t>

                <t>
                    There SHOULD NOT be two identical "id" values in the same schema which resolve
                    to the same URI. If this is the case, subschema lookup using inner schema
                    addressing is undefined.
                </t>

                <t>
                    This schema will be taken as an example:
                </t>

                <!-- FIXME: http again as a scheme, maybe another one? It can be any scheme after
                all -->
                <figure>
                    <artwork>
<![CDATA[
{
    "id": "http://x.y.z/rootschema.json#",
    "schema1": {
        "id": "#foo"
    },
    "schema2": {
        "id": "otherschema.json",
        "nested": {
            "id": "#bar"
        },
        "alsonested": {
            "id": t/inner.json#a"
        }
    },
    "schema3": {
        "id": "some://where.else/completely#"
    }
}
]]>
                    </artwork>
                </figure>
                
                <t>
                    Subschemas at the following URI-encoded <xref target="json-pointer">JSON
                    Pointer</xref>s (starting from the root schema) have the following URIs:
 
                    <list style="hanging">
                        <t hangText="# (document root)">http://x.y.z/rootschema.json#</t>
                        <t hangText="#/schema1">http://x.y.z/rootschema.json#foo</t>
                        <t hangText="#/schema2">http://x.y.z/otherschema.json#</t>
                        <t hangText="#/schema2/nested">http://x.y.z/rootschema.json#bar</t>
                        <t hangText="#/schema2/alsonested">http://x.y.z/t/inner.json#a</t>
                        <t hangText="#/schema3">some://where.else/completely#</t>
                    </list>
                </t>

            </section>

            <section title="Security considerations">
                <t>
                    Inner schema addressing can produce canonical URIs which differ from the
                    canonical URI of the root schema. Implementations MAY choose, for security
                    reasons, to ignore inner schema addressing, and always dereference canonical
                    URIs. Schema authors SHALL NOT expect that inner schema addressing be used by
                    an implementation.
                </t>

                <t>
                    Dereferencing URIs may fail to complete, or may lead to content which is not a
                    JSON Schema (another type of JSON value, or not a JSON value). It is RECOMMENDED
                    that JSON Schema processing be stopped in such a situation.
                </t>
            </section>
        </section>

        <section title="Schema/Instance Association">

            <section title="Purpose of this section">
                <t>
                    A JSON instance MAY be correlated to one, or even several, JSON Schemas. This
                    correlation MAY be embodied within existing protocol headers.
                </t>

                <t>
                    In addition, if the protocol also carries media type information (by means, for
                    instance, of a "Content-Type" header), an instance MUST be one of
                    "application/json" or any other subtype.
                </t>

                <t>
                    Should the scenario above be inapplicable, due either to the absence of, or
                    restrictions on, protocol headers, such a correlation is out of the normative
                    scope of this specification.
                </t>
            </section>

            <section title="Recommended correlation mechanisms for use with the HTTP protocol">

                <t>
                    It is acknowledged by this specification that the majority of interactive JSON
                    Schema processing will be over HTTP. This section therefore gives
                    recommendations for materializing an instance/schema correlation using
                    mechanisms currently available for this protocol.
                </t>

                <section title='Correlation by means of the "Content-Type" header'>
                    <t>
                        It is RECOMMENDED that a MIME type parameter by the name of "profile" be
                        appended to the "Content-Type" header of the instance being processed. If
                        present, the value of this parameter MUST be a valid URI, and this URI
                        SHOULD resolve to a valid JSON Schema.
                    </t>

                    <t>
                        An example of such a header would be:
                    </t>
                      
                    <figure>
                        <artwork>
<![CDATA[
Content-Type: application/my-media-type+json;
              profile=http://example.com/my-hyper-schema
]]>
                        </artwork>
                    </figure>

                </section>

                <section title='Correlation by means of the "Link" header'>
                    <t>
                        When using the "Link" header, it is RECOMMENDED that a relationship by the
                        name "describedBy" be used, as defined by RFC 2048, section 19.6.2.4 (FIXME:
                        make real link). Note: it should be remembered that relationship values are
                        case insensitive, so "describedBy" is just as valid a relationship as
                        "DESCRIBEDBY".
                    </t>

                    <t>
                        The target URI of the "Link" header SHOULD be a valid JSON Schema.
                    </t>

                    <t>
                        An example of such a header would be:
                    </t>

                    <figure>
                        <artwork>
<![CDATA[
Link: <http://example.com/my-hyper-schema>; rel="describedBy"
]]>
                        </artwork>
                    </figure>

                </section>
            </section>

        </section>

        <section title="IANA Considerations">
            <t>
                The proposed MIME media type for JSON Schema is defined as follows:

                <list>
                    <t>type name: application;</t>
                    <t>subtype name: schema+json.</t>
                </list>
            </t>

        </section>
    </middle>

    <back>
        <!-- References Section -->
        <references title="Normative References">
            &RFC2119;
            <reference anchor="json-reference"
                target="http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03">
                <front>
                    <title>JSON Reference</title>
                    <author initials="P." surname="Bryan">
                        <organization>ForgeRock US, Inc.</organization>
                    </author>
                    <author initials="K." surname="Zyp">
                        <organization>SitePen (USA)</organization>
                    </author>
                    <date year="2012" month="September"/>
                </front>
            </reference>
            <reference anchor="json-pointer"
                target="http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-04">
                <front>
                    <title>JSON Pointer</title>
                    <author initials="P." surname="Bryan">
                        <organization>ForgeRock US, Inc.</organization>
                    </author>
                    <author initials="K." surname="Zyp">
                        <organization>SitePen (USA)</organization>
                    </author>
                    <date year="2012" month="September"/>
                </front>
            </reference>
            <reference anchor="json-schema-03"
                target="http://tools.ietf.org/html/draft-zyp-json-schema-03">
                <front>
                    <title>JSON Schema, draft 3</title>
                    <author initials="G." surname="Court">
                        <organization/>
                    </author>
                    <author initials="K." surname="Zyp">
                        <organization>SitePen (USA)</organization>
                    </author>
                    <date year="2012" month="September"/>
                </front>
            </reference>
        </references>
        <references title="Informative References">
            &RFC4627;
            &RFC3986;
        </references>

        <section title="ChangeLog">
            <t>TODO</t>
            <!--
            <t>
                <list style="hanging">
                    <t hangText="draft-04">
                        <list style="symbols">
                            <t>Changed "required" attribute to an array of strings.</t>
                            <t>Removed "format" attribute.</t>
                            <t>Added "minProperties" and "maxProperties" attributes.</t>
                            <t>Replaced "slash-delimited" fragment resolution with
                            "json-pointer".</t>
                            <t>Added "template" LDO attribute.</t>
                            <t>Removed irrelevant "Open Issues" section.</t>
                            <t>Merged Conventions and Terminology sections.</t>
                            <t>Defined terms used in specification.</t>
                            <t>Restricted "type" to only the core JSON types.</t>
                            <t>Renamed "divisibleBy" to "mod".</t>
                            <t>Improved wording of many sections.</t>
                        </list>
                    </t>

                    <t hangText="draft-03">
                        <list style="symbols">
                            <t>Added example and verbiage to "extends" attribute.</t>
                            <t>Defined slash-delimited to use a leading slash.</t>
                            <t>Made "root" a relation instead of an attribute.</t>
                            <t>Removed address values, and MIME media type from format to reduce
                            confusion (mediaType already exists, so it can be used for MIME
                            types).</t>
                            <t>Added more explanation of nullability.</t>
                            <t>Removed "alternate" attribute.</t>
                            <t>Upper cased many normative usages of must, may, and should.</t>
                            <t>Replaced the link submission "properties" attribute to "schema"
                            attribute.</t>
                            <t>Replaced "optional" attribute with "required" attribute.</t>
                            <t>Replaced "maximumCanEqual" attribute with "exclusiveMaximum"
                            attribute.</t>
                            <t>Replaced "minimumCanEqual" attribute with "exclusiveMinimum"
                            attribute.</t>
                            <t>Replaced "requires" attribute with "dependencies" attribute.</t>
                            <t>Moved "contentEncoding" attribute to hyper schema.</t>
                            <t>Added "additionalItems" attribute.</t>
                            <t>Added "id" attribute.</t>
                            <t>Switched self-referencing variable substitution from "-this" to "@"
                            to align with reserved characters in URI template.</t>
                            <t>Added "patternProperties" attribute.</t>
                            <t>Schema URIs are now namespace versioned.</t>
                            <t>Added "$ref" and "$schema" attributes.</t>
                        </list>
                    </t>

                    <t hangText="draft-02">
                        <list style="symbols">
                            <t>Replaced "maxDecimal" attribute with "divisibleBy" attribute.</t>
                            <t>Added slash-delimited fragment resolution protocol and made it the
                            default.</t>
                            <t>Added language about using links outside of schemas by referencing
                            its normative URI.</t>
                            <t>Added "uniqueItems" attribute.</t>
                            <t>Added "targetSchema" attribute to link description object.</t>
                        </list>
                    </t>

                    <t hangText="draft-01">
                        <list style="symbols">
                            <t>Fixed category and updates from template.</t>
                        </list>
                    </t>

                    <t hangText="draft-00">
                        <list style="symbols">
                            <t>Initial draft.</t>
                        </list>
                    </t>
                </list>
            </t>
            -->
        </section>
    </back>
</rfc>
